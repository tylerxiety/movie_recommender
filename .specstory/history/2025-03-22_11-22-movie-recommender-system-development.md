<!-- Generated by SpecStory -->

# Movie Recommender System Development (2025-03-22 19:22:29)

_**User**_

please build a movie recommneder system that recommends movies similar to my highly rated ones. the similarity is based on plot description. use movies_dataset_48k.csv for plot and movie info data. embed the ‘Description’ column in movies_dataset_48k.csv using Hugging Face Transformers’ all-MiniLM-L6-v2(i perfer using Hugging Face over sentence-transformers), and store it using faiss. rank similarity using faiss. use my_movie_ratings.csv for my ratings.  the system is a Flash web app running locally. i am using mackbook air with m1 chip. the system recommends 10 movies, showing info including image, title, cast, published date/year, description, etc, which can be found from the movies_dataset_48k.csv data. it also has a rating feature, to update the recommendations. this a minimal viable product, so there will be future improvement including better/more data, algorithms, features, and hosting, etc. please install pytorch using conda, and other packages using pip. the virtual env has been actiavted.

---

_**Assistant**_

# Movie Recommender System

I'll build a movie recommender system based on plot similarity that recommends movies similar to ones you've highly rated. Let's break this down into steps:

1. Set up the environment
2. Load and process the data
3. Create embeddings using Hugging Face's all-MiniLM-L6-v2
4. Build a FAISS index for similarity search
5. Create a Flask web app with recommendation and rating features

## Step 1: Set up the environment

First, let's install the required packages:

```bash
# Install PyTorch using conda for M1 Mac
conda install pytorch -c pytorch

# Install other dependencies using pip
pip install flask pandas numpy faiss-cpu transformers pillow
```

## Step 2: Create the project structure

```bash
mkdir movie_recommender
cd movie_recommender
mkdir templates static
mkdir static/css static/js static/images
touch app.py recommender.py
```

## Step 3: Build the recommender system

Let's create `recommender.py` for the core recommendation logic:

```python:recommender.py
import pandas as pd
import numpy as np
import faiss
import torch
from transformers import AutoTokenizer, AutoModel
import os
import pickle

class MovieRecommender:
    def __init__(self, movies_path, ratings_path, model_name="sentence-transformers/all-MiniLM-L6-v2"):
        self.model_name = model_name
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name)
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
        
        # Load data
        self.movies_df = pd.read_csv(movies_path)
        self.ratings_df = pd.read_csv(ratings_path)
        
        # Check if embeddings and index already exist
        if os.path.exists('movie_embeddings.pkl') and os.path.exists('faiss_index.pkl'):
            self.load_embeddings_and_index()
        else:
            self.create_embeddings_and_index()
    
    def mean_pooling(self, model_output, attention_mask):
        # Mean pooling - take average of all tokens
        token_embeddings = model_output[0]
        input_mask_expanded = attention_mask.unsqueeze(-1).expand(token_embeddings.size()).float()
        return torch.sum(token_embeddings * input_mask_expanded, 1) / torch.clamp(input_mask_expanded.sum(1), min=1e-9)
    
    def get_embedding(self, text):
        # Tokenize sentences
        encoded_input = self.tokenizer(text, padding=True, truncation=True, return_tensors='pt').to(self.device)
        
        # Compute token embeddings
        with torch.no_grad():
            model_output = self.model(**encoded_input)
        
        # Perform mean pooling
        embeddings = self.mean_pooling(model_output, encoded_input['attention_mask'])
        return embeddings.cpu().numpy()
    
    def create_embeddings_and_index(self):
        print("Creating movie embeddings...")
        # Get embeddings for all movie descriptions
        self.movies_df = self.movies_df.dropna(subset=['Description'])
        descriptions = self.movies_df['Description'].tolist()
        
        # Process in batches to avoid memory issues
        batch_size = 128
        all_embeddings = []
        
        for i in range(0, len(descriptions), batch_size):
            batch = descriptions[i:i+batch_size]
            embeddings = self.get_embedding(batch)
            all_embeddings.append(embeddings)
            print(f"Processed {i+len(batch)}/{len(descriptions)} descriptions")
        
        self.embeddings = np.vstack(all_embeddings)
        
        # Create FAISS index
        print("Creating FAISS index...")
        dim = self.embeddings.shape[1]
        self.index = faiss.IndexFlatIP(dim)  # Inner product for cosine similarity with normalized vectors
        
        # Normalize embeddings for cosine similarity
        faiss.normalize_L2(self.embeddings)
        self.index.add(self.embeddings)
        
        # Save embeddings and index
        with open('movie_embeddings.pkl', 'wb') as f:
            pickle.dump(self.embeddings, f)
        
        with open('faiss_index.pkl', 'wb') as f:
            pickle.dump(self.index, f)
    
    def load_embeddings_and_index(self):
        print("Loading existing embeddings and index...")
        with open('movie_embeddings.pkl', 'rb') as f:
            self.embeddings = pickle.load(f)
        
        with open('faiss_index.pkl', 'rb') as f:
            self.index = pickle.load(f)
    
    def get_recommendations(self, num_recommendations=10):
        # Get highly rated movies (ratings >= 4)
        highly_rated = self.ratings_df[self.ratings_df['Rating'] >= 4]['MovieID'].tolist()
        
        if not highly_rated:
            # If no highly rated movies, return top-rated movies overall
            return self.movies_df.head(num_recommendations).index.tolist()
        
        # Get indices of highly rated movies
        highly_rated_indices = []
        for movie_id in highly_rated:
            indices = self.movies_df[self.movies_df['MovieID'] == movie_id].index.tolist()
            if indices:
                highly_rated_indices.append(indices[0])
        
        if not highly_rated_indices:
            return self.movies_df.head(num_recommendations).index.tolist()
        
        # Get embeddings of highly rated movies
        query_embeddings = self.embeddings[highly_rated_indices]
        
        # Average the embeddings to get a representation of user preference
        avg_embedding = np.mean(query_embeddings, axis=0).reshape(1, -1)
        faiss.normalize_L2(avg_embedding)
        
        # Search for similar movies
        D, I = self.index.search(avg_embedding, num_recommendations + len(highly_rated_indices))
        
        # Filter out movies that are already rated
        recommendations = [idx for idx in I[0] if idx not in highly_rated_indices][:num_recommendations]
        
        return recommendations
    
    def update_rating(self, movie_id, rating):
        # Update existing rating or add new rating
        if self.ratings_df['MovieID'].eq(movie_id).any():
            self.ratings_df.loc[self.ratings_df['MovieID'] == movie_id, 'Rating'] = rating
        else:
            new_rating = pd.DataFrame({'MovieID': [movie_id], 'Rating': [rating]})
            self.ratings_df = pd.concat([self.ratings_df, new_rating], ignore_index=True)
        
        # Save updated ratings
        self.ratings_df.to_csv('my_movie_ratings.csv', index=False)
```

## Step 4: Create the Flask application

Now, let's create `app.py` to serve the web interface:

```python:app.py
from flask import Flask, render_template, request, jsonify
from recommender import MovieRecommender
import pandas as pd

app = Flask(__name__)

# Initialize recommender
recommender = MovieRecommender('movies_dataset_48k.csv', 'my_movie_ratings.csv')

@app.route('/')
def index():
    # Get recommendations
    recommendations = recommender.get_recommendations(10)
    
    # Get recommended movies data
    recommended_movies = recommender.movies_df.iloc[recommendations]
    
    # Convert to list of dictionaries for template rendering
    movies = []
    for _, movie in recommended_movies.iterrows():
        movie_data = {
            'id': movie.get('MovieID', ''),
            'title': movie.get('Title', 'Unknown Title'),
            'description': movie.get('Description', 'No description available'),
            'cast': movie.get('Cast', 'Unknown cast'),
            'year': movie.get('Year', '') or movie.get('Release_Date', 'Unknown year'),
            'image': movie.get('Poster_Url', '') or 'static/images/default_poster.png'
        }
        movies.append(movie_data)
    
    # Get current ratings
    ratings = recommender.ratings_df.set_index('MovieID')['Rating'].to_dict()
    
    return render_template('index.html', movies=movies, ratings=ratings)

@app.route('/rate', methods=['POST'])
def rate_movie():
    movie_id = request.form.get('movie_id')
    rating = float(request.form.get('rating'))
    
    # Update rating
    recommender.update_rating(movie_id, rating)
    
    return jsonify({'success': True})

@app.route('/refresh', methods=['GET'])
def refresh_recommendations():
    # Get recommendations
    recommendations = recommender.get_recommendations(10)
    
    # Get recommended movies data
    recommended_movies = recommender.movies_df.iloc[recommendations]
    
    # Convert to list of dictionaries for template rendering
    movies = []
    for _, movie in recommended_movies.iterrows():
        movie_data = {
            'id': movie.get('MovieID', ''),
            'title': movie.get('Title', 'Unknown Title'),
            'description': movie.get('Description', 'No description available'),
            'cast': movie.get('Cast', 'Unknown cast'),
            'year': movie.get('Year', '') or movie.get('Release_Date', 'Unknown year'),
            'image': movie.get('Poster_Url', '') or 'static/images/default_poster.png'
        }
        movies.append(movie_data)
    
    return jsonify(movies)

if __name__ == '__main__':
    app.run(debug=True)
```

## Step 5: Create HTML templates

Let's create an HTML template for the web interface:

```html:templates/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Recommender</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <div class="container mt-4">
        <h1 class="mb-4">Movie Recommender</h1>
        <p class="mb-4">Based on your highly rated movies, we recommend these movies with similar plots:</p>
        
        <button id="refresh-btn" class="btn btn-primary mb-4">Refresh Recommendations</button>
        
        <div id="recommendations" class="row">
            {% for movie in movies %}
            <div class="col-md-6 mb-4">
                <div class="card h-100">
                    <div class="row g-0">
                        <div class="col-md-4">
                            <img src="{{ movie.image }}" class="img-fluid rounded-start movie-poster" alt="{{ movie.title }}" onerror="this.src='{{ url_for('static', filename='images/default_poster.png') }}'">
                        </div>
                        <div class="col-md-8">
                            <div class="card-body">
                                <h5 class="card-title">{{ movie.title }}</h5>
                                <p class="card-text"><small class="text-muted">{{ movie.year }}</small></p>
                                <p class="card-text"><strong>Cast:</strong> {{ movie.cast }}</p>
                                <p class="card-text description">{{ movie.description }}</p>
                                <div class="rating">
                                    <p><strong>Rate this movie:</strong></p>
                                    <div class="stars" data-movie-id="{{ movie.id }}">
                                        {% for i in range(1, 6) %}
                                            <span class="star {% if ratings.get(movie.id, 0) >= i %}active{% endif %}" data-rating="{{ i }}">★</span>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
```

## Step 6: Add CSS and JavaScript

Let's add some styling:

```css:static/css/styles.css
.movie-poster {
    width: 100%;
    height: 100%;
    object-fit: cover;
    max-height: 300px;
}

.description {
    max-height: 150px;
    overflow-y: auto;
}

.stars {
    font-size: 24px;
    cursor: pointer;
}

.star {
    color: #ccc;
    display: inline-block;
    transition: color 0.2s ease;
}

.star:hover,
.star.active {
    color: gold;
}

.star:hover ~ .star {
    color: #ccc;
}
```

And add JavaScript for interactivity:

```javascript:static/js/script.js
$(document).ready(function() {
    // Handle star rating
    $('.stars').each(function() {
        const $stars = $(this).find('.star');
        const movieId = $(this).data('movie-id');
        
        $stars.on('click', function() {
            const rating = $(this).data('rating');
            
            // Update UI
            $stars.removeClass('active');
            $(this).addClass('active').prevAll('.star').addClass('active');
            
            // Send rating to server
            $.post('/rate', {
                movie_id: movieId,
                rating: rating
            });
        });
    });
    
    // Refresh recommendations
    $('#refresh-btn').on('click', function() {
        $.get('/refresh', function(data) {
            // Clear current recommendations
            $('#recommendations').empty();
            
            // Add new recommendations
            data.forEach(function(movie) {
                const html = `
                <div class="col-md-6 mb-4">
                    <div class="card h-100">
                        <div class="row g-0">
                            <div class="col-md-4">
                                <img src="${movie.image}" class="img-fluid rounded-start movie-poster" alt="${movie.title}" onerror="this.src='/static/images/default_poster.png'">
                            </div>
                            <div class="col-md-8">
                                <div class="card-body">
                                    <h5 class="card-title">${movie.title}</h5>
                                    <p class="card-text"><small class="text-muted">${movie.year}</small></p>
                                    <p class="card-text"><strong>Cast:</strong> ${movie.cast}</p>
                                    <p class="card-text description">${movie.description}</p>
                                    <div class="rating">
                                        <p><strong>Rate this movie:</strong></p>
                                        <div class="stars" data-movie-id="${movie.id}">
                                            <span class="star" data-rating="1">★</span>
                                            <span class="star" data-rating="2">★</span>
                                            <span class="star" data-rating="3">★</span>
                                            <span class="star" data-rating="4">★</span>
                                            <span class="star" data-rating="5">★</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                `;
                
                $('#recommendations').append(html);
            });
            
            // Reattach event handlers
            $('.stars').each(function() {
                const $stars = $(this).find('.star');
                const movieId = $(this).data('movie-id');
                
                $stars.on('click', function() {
                    const rating = $(this).data('rating');
                    
                    // Update UI
                    $stars.removeClass('active');
                    $(this).addClass('active').prevAll('.star').addClass('active');
                    
                    // Send rating to server
                    $.post('/rate', {
                        movie_id: movieId,
                        rating: rating
                    });
                });
            });
        });
    });
});
```

## Step 7: Create a default poster image

You'll need a default poster image for movies without posters. You can add a default image to the `static/images` directory.

## Step 8: Run the application

Finally, you can run the application:

```bash
python app.py
```

Visit http://127.0.0.1:5000/ in your browser to use the recommender system.

## How it works

1. **Data Loading**: The system loads movie data from `movies_dataset_48k.csv` and your ratings from `my_movie_ratings.csv`.

2. **Embedding Generation**: It uses Hugging Face's all-MiniLM-L6-v2 model to generate embeddings for movie descriptions.

3. **Similarity Search**: FAISS is used to efficiently find movies with similar plot descriptions to your highly rated movies.

4. **Recommendation Process**:
   - The system identifies your highly rated movies (rating ≥ 4)
   - It finds the average embedding of these movies' descriptions
   - It searches for similar movies using FAISS
   - It filters out movies you've already rated
   - It returns the top 10 recommendations

5. **Rating System**: You can rate movies from 1-5 stars, which updates your ratings file and affects future recommendations.

6. **Web Interface**: The Flask app provides a clean interface showing movie details including title, cast, year, description, and poster image.

This MVP provides a solid foundation for your recommender system, which you can later enhance with better algorithms, more data, and additional features.

---



---

